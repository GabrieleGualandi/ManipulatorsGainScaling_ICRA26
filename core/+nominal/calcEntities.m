function ent = calcEntities(par, st, desired)
% SPDX-License-Identifier: Apache-2.0
% Copyright (c) 2026 Gabriele Gualandi
%
% NOMINAL.CALCENTITIES Updates geometric entities and tracking errors.
% This function calculates the forward kinematics (position, orientation) 
% and Differential Kinematics (Jacobians, velocities) for the Real, 
% Estimated, and Sensing-Free Projected states. It also computes the 
% corresponding pose and velocity tracking errors.
%
% Inputs:
%   par     - Configuration structure.
%   st      - Current SimulatorState object.
%   desired - Reference trajectory structure.
%
% Outputs:
%   ent     - Structure containing geometry objects and error vectors for 
%             all relevant state snapshots.
%
% SEE ALSO: NOMINAL.GEOMETRY, NOMINAL.COMPUTEERRORPOSE, CORE_CONTROL


    % 1. Real Geometry & Errors
    ent.geometryReal = nominal.geometry(par.funcs.J_func_task, ...
        par.funcs.Jdot_func_task, ...
        par.funcs.HT_hand_func, ...
        par.task.taskP, ...
        st.sys_real_q, st.sys_real_qdot);

    ent.errors = struct();
    ent.errors.real.pose = nominal.computeErrorPose( ...
        ent.geometryReal.handPosition_task, ...
        ent.geometryReal.handOrientation, ...
        desired.desired_position(par.task.taskP,:), ...
        desired.desired_orientation, ...
        par.task.taskO);
    ent.errors.real.vel = desired.desired_spatial_velocity(par.task.taskSpaceRows) - ent.geometryReal.handGeneralizedVelocity_task;

    % 2. Estimated Geometry & Errors
    if isequal(st.sys_observer_q_hat, st.sys_real_q) && isequal(st.sys_observer_qdot_hat, st.sys_real_qdot)
        % Optimization: Reuse Real geometry if states are identical
        ent.geometryEstimated = ent.geometryReal;
        ent.errors.estimated = ent.errors.real;
    else
        ent.geometryEstimated = nominal.geometry(par.funcs.J_func_task, ...
            par.funcs.Jdot_func_task, ...
            par.funcs.HT_hand_func, ...
            par.task.taskP, ...
            st.sys_observer_q_hat, st.sys_observer_qdot_hat);

        ent.errors.estimated.pose = nominal.computeErrorPose( ...
            ent.geometryEstimated.handPosition_task, ...
            ent.geometryEstimated.handOrientation, ...
            desired.desired_position(par.task.taskP,:), ...
            desired.desired_orientation, ...
            par.task.taskO);
        ent.errors.estimated.vel = desired.desired_spatial_velocity(par.task.taskSpaceRows) - ent.geometryEstimated.handGeneralizedVelocity_task;
    end

    % 3. Sensing-Free Projected Geometry & Errors
    % Check against Real first (likeliest match in ideal cases)
    if isequal(st.sys_sensingFreeProjected_q, st.sys_real_q) && isequal(st.sys_sensingFreeProjected_qdot, st.sys_real_qdot)
        ent.geometrySensingFreeProjected = ent.geometryReal;
        ent.errors.sensingFreeProjected = ent.errors.real;
    % Check against Estimated next
    elseif isequal(st.sys_sensingFreeProjected_q, st.sys_observer_q_hat) && isequal(st.sys_sensingFreeProjected_qdot, st.sys_observer_qdot_hat)
        ent.geometrySensingFreeProjected = ent.geometryEstimated;
        ent.errors.sensingFreeProjected = ent.errors.estimated;
    else
        ent.geometrySensingFreeProjected = nominal.geometry(par.funcs.J_func_task, ...
            par.funcs.Jdot_func_task, ...
            par.funcs.HT_hand_func, ...
            par.task.taskP, ...
            st.sys_sensingFreeProjected_q, st.sys_sensingFreeProjected_qdot);

        ent.errors.sensingFreeProjected.pose = nominal.computeErrorPose( ...
            ent.geometrySensingFreeProjected.handPosition_task, ...
            ent.geometrySensingFreeProjected.handOrientation, ...
            desired.desired_position(par.task.taskP,:), ...
            desired.desired_orientation, ...
            par.task.taskO);
        ent.errors.sensingFreeProjected.vel = desired.desired_spatial_velocity(par.task.taskSpaceRows) - ent.geometrySensingFreeProjected.handGeneralizedVelocity_task;
    end

end